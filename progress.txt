# LearningPlayer Decomposition Progress

## Phase 1 Complete: Cycle Foundation
Created atomic Cycle types with validation, playback composable, player component.
- Cycle type definitions (types/Cycle.ts)
- validateCycle / validateSession (utils/validateCycle.ts)
- useCyclePlayback composable
- CyclePlayer.vue component (154 lines)
- 11 tests passing
- Test page at /test/cycle

## Phase 2: Decomposition (Current)

### Goal
Decompose 5000-line LearningPlayer.vue into focused modules using the Cycle foundation.

### Target Architecture
```
LearningSession.vue (thin orchestrator, <200 lines)
├── useSessionManager (queue, progression)
├── CyclePlayer (plays one cycle)
├── Events → Network visualization
├── Events → Belt progress
└── scriptItemToCycle bridge (gradual migration)
```

### Key Principle
LearningPlayer.vue stays working throughout. New modules are built alongside, wired via feature flag.

## Completed Tasks (Phase 2)
1. Created useSessionManager composable - queue/progression logic extracted
2. Wrote useSessionManager tests - 11 tests, all passing (22 total tests)
3. Created scriptItemToCycle bridge converter - maps ScriptItem to Cycle format
4-8. Created LearningSession.vue orchestrator (186 lines) with:
  - Session validation gate (blocks until audio ready)
  - Network visualization events (cycle-started with legoId)
  - Belt progress events (cycle-complete with cycle)
  - Skip and jump controls (exposed via ref)

## Current Blockers
(none)

## Notes for Next Iteration
Start with item 1: Create useSessionManager composable.
This extracts queue/progression logic from LearningPlayer.
Key methods: getCurrentCycle, getNextCycle, markCycleComplete, skipToNext, jumpTo.
