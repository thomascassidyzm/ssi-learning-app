/**
 * Auto-generated TypeScript types from Registry AST
 * DO NOT EDIT - Generated by registry-compiler
 */

// ============================================
// ENUMS
// ============================================

/** Lifecycle status for content items */
export enum ContentStatus {
  /** In development, not visible to learners */
  draft = 'draft',
  /** Live, available to learners */
  released = 'released',
  /** Superseded, hidden from new learners but preserved */
  deprecated = 'deprecated'
}

/** Classification of LEGO building blocks */
export enum LegoType {
  /** Single semantic unit, cannot be split further */
  A = 'A',
  /** Multi-word phrase composed of atomic parts */
  M = 'M'
}

/** Classification of practice phrases in learning sequence */
export enum PhraseType {
  /** Building block words from M-type LEGO breakdown */
  component = 'component',
  /** The LEGO itself as a complete unit */
  lego = 'lego',
  /** Scaffolding phrases of increasing complexity (up to 7) */
  debut = 'debut',
  /** The 5 longest phrases from basket - used forever on revisits */
  eternal = 'eternal'
}

/** Role of audio in the learning cycle */
export enum AudioRole {
  /** Known language prompt audio */
  source = 'source',
  /** Target language, primary voice */
  target1 = 'target1',
  /** Target language, secondary voice */
  target2 = 'target2',
  /** LEGO introduction explanation audio */
  presentation = 'presentation'
}

/** Classification of learner's overall processing speed */
export enum TempoBand {
  /** Very quick processor */
  very_fast = 'very_fast',
  /** Quick processor */
  fast = 'fast',
  /** Average processing speed */
  medium = 'medium',
  /** Slower processor - needs more time */
  slow = 'slow',
  /** Very slow processor - needs significant time */
  very_slow = 'very_slow'
}

/** Classification of learner's response consistency */
export enum ConsistencyBand {
  /** Very tight response pattern */
  very_consistent = 'very_consistent',
  /** Normal response variation */
  consistent = 'consistent',
  /** Wide variation in responses */
  variable = 'variable',
  /** Very inconsistent responses */
  highly_variable = 'highly_variable'
}

// ============================================
// INTERFACES
// ============================================

/** A language course configuration */
export interface Course {
  course_code: string;
  /** ISO 639-3 code for known language */
  known_lang: string;
  /** ISO 639-3 code for target language */
  target_lang: string;
  display_name?: string;
  /** Voice ID for known language audio */
  known_voice: string;
  /** Primary voice ID for target language */
  target_voice_1: string;
  /** Secondary voice ID for target language */
  target_voice_2: string;
  /** Voice for presentation audio (defaults to known_voice) */
  presentation_voice?: string;
  status: ContentStatus;
  created_at?: Date;
  updated_at?: Date;
}

/** A seed sentence for a specific course */
export interface CourseSeed {
  /** Stable identifier for references */
  id?: string;
  course_code: string;
  /** Position in learning sequence */
  seed_number: number;
  /** Full sentence in known language */
  known_text: string;
  /** Full sentence in target language */
  target_text: string;
  status: ContentStatus;
  /** For staged rollout (batch 1, 2, 3...) */
  release_batch?: number;
  /** Increment on each edit for delta sync */
  version: number;
  updated_at?: Date;
}

/** A LEGO building block within a course seed */
export interface CourseLego {
  id?: string;
  course_code: string;
  /** Parent seed's position */
  seed_number: number;
  /** Position within seed */
  lego_index: number;
  /** A (Atomic) or M (Molecular) */
  type: LegoType;
  /** True if first appearance in this course */
  is_new: boolean;
  known_text: string;
  target_text: string;
  /** Atomic breakdown of molecular LEGO */
  components?: LanguagePair[];
  status: ContentStatus;
  version: number;
  updated_at?: Date;
}

/** A practice phrase for a LEGO */
export interface CoursePracticePhrase {
  id?: string;
  course_code: string;
  seed_number: number;
  lego_index: number;
  /** Sequential position in LEGO's practice phrase basket (1, 2, 3...) */
  position: number;
  /** Word count in target language for classification */
  word_count: number;
  /** Number of unique LEGOs used in phrase */
  lego_count: number;
  known_text: string;
  target_text: string;
  /** Learner difficulty rating */
  difficulty?: 'easy' | 'medium' | 'hard';
  /** Language register */
  register?: 'casual' | 'formal';
  /** Future extensions without schema changes */
  metadata?: Record<string, unknown>;
  status: ContentStatus;
  version: number;
  updated_at?: Date;
}

/** A single audio recording, reusable across courses */
export interface AudioSample {
  uuid: string;
  /** Original text as authored */
  text: string;
  /** Lowercase, trimmed for matching */
  text_normalized: string;
  /** ISO 639-3 code */
  language: string;
  voice_id: string;
  /** source | target1 | target2 | presentation */
  role: AudioRole;
  s3_key?: string;
  /** Audio duration in milliseconds */
  duration_ms?: number;
  /** QA workflow status */
  status: 'pending' | 'approved' | 'rejected';
  version: number;
  updated_at?: Date;
}

/** Course welcome message, one per course */
export interface CanonicalWelcome {
  course_code: string;
  /** Full welcome text */
  text: string;
  /** Optional short version */
  text_short?: string;
  /** Reference to audio sample */
  audio_uuid?: string;
  /** Voice used for welcome */
  voice_id: string;
  /** Language welcome is spoken in (typically known_lang) */
  language: string;
  version: string;
  created_at?: Date;
  updated_at?: Date;
}

/** Motivational messages for learners */
export interface CanonicalEncouragement {
  id?: number;
  /** Encouragement text */
  text: string;
  /** pooled = random selection, ordered = sequential */
  type: 'pooled' | 'ordered';
  /** For ordered encouragements (1, 2, 3...) */
  order_position?: number;
  audio_uuid?: string;
  voice_id?: string;
  /** Typically English for English-known courses */
  language: string;
  /** Tags for filtering/selection */
  tags?: string[];
  /** Don't play until learner has done N seeds */
  min_seeds_completed?: number;
  /** Max times to play this encouragement */
  max_plays?: number;
  is_active: boolean;
  created_at?: Date;
  updated_at?: Date;
}

/** Learner account and profile */
export interface Learner {
  id?: string;
  /** Reference to auth.users (Supabase auth) */
  user_id: string;
  display_name: string;
  /** Learner preferences */
  preferences: Record<string, unknown>;
  created_at?: Date;
  updated_at?: Date;
}

/** Learner enrollment in a course */
export interface CourseEnrollment {
  id?: string;
  /** Reference to learner account */
  learner_id: string;
  course_code: string;
  enrolled_at: Date;
  last_practiced_at?: Date;
  total_practice_minutes: number;
  /** Triple Helix thread state */
  helix_state: Record<string, unknown>;
}

/** Per-LEGO spaced repetition state for a learner */
export interface LegoProgress {
  id?: string;
  learner_id: string;
  /** Reference to LEGO (e.g., S0001L01) */
  lego_id: string;
  /** Course code */
  course_id: string;
  /** Which helix thread (1, 2, or 3) */
  thread_id: number;
  /** Position in Fibonacci sequence */
  fibonacci_position: number;
  /** Number of items to skip before next review */
  skip_number: number;
  /** Number of times practiced */
  reps_completed: number;
  /** Has LEGO reached retirement threshold */
  is_retired: boolean;
  last_practiced_at?: Date;
  created_at?: Date;
  updated_at?: Date;
}

/** Track which seeds a learner has seen */
export interface SeedProgress {
  id?: string;
  learner_id: string;
  /** Reference to seed (e.g., S0001) */
  seed_id: string;
  course_id: string;
  thread_id: number;
  is_introduced: boolean;
  introduced_at?: Date;
  created_at?: Date;
  updated_at?: Date;
}

/** Individual practice session */
export interface Session {
  id?: string;
  learner_id: string;
  course_id: string;
  started_at: Date;
  ended_at?: Date;
  duration_seconds: number;
  items_practiced: number;
  /** Number of hesitation/difficulty spikes detected */
  spikes_detected: number;
  /** Final rolling average of normalized latencies */
  final_rolling_average: number;
}

/** Individual response time metric during practice */
export interface ResponseMetric {
  /** Database primary key */
  db_id?: string;
  /** Client-generated ID for deduplication */
  id: string;
  session_id: string;
  learner_id: string;
  course_id: string;
  lego_id: string;
  timestamp: Date;
  /** Raw response time in milliseconds */
  response_latency_ms: number;
  /** Length of phrase (for normalization) */
  phrase_length: number;
  /** Latency normalized by phrase length */
  normalized_latency: number;
  /** Which helix thread */
  thread_id: number;
  /** Whether this response triggered a difficulty spike */
  triggered_spike: boolean;
  /** Learning mode during response */
  mode: string;
}

/** Detected hesitation/difficulty spike */
export interface SpikeEvent {
  db_id?: string;
  /** Client-generated ID */
  id: string;
  session_id: string;
  learner_id: string;
  course_id: string;
  lego_id: string;
  timestamp: Date;
  /** Normalized latency that triggered spike */
  latency: number;
  /** Rolling average at time of spike */
  rolling_average: number;
  /** Ratio of latency to rolling average */
  spike_ratio: number;
  /** How system responded to spike */
  response: 'repeat' | 'breakdown';
  thread_id: number;
}

/** Calibrated timing baseline per learner per course for continuous adaptation */
export interface LearnerBaseline {
  id?: string;
  learner_id: string;
  /** Course code (baseline may vary by language pair) */
  course_id: string;
  /** When the baseline was established */
  calibrated_at: Date;
  /** Number of items used to establish baseline */
  calibration_items: number;
  /** Mean normalized latency (ms per character) */
  latency_mean: number;
  /** Standard deviation of normalized latency */
  latency_std_dev: number;
  /** Mean difference between learner and model duration (ms) */
  duration_delta_mean: number;
  /** Standard deviation of duration delta */
  duration_delta_std_dev: number;
  /** Whether microphone/VAD timing was available during calibration */
  had_timing_data: boolean;
  /** Optional metadata (device type, notes, etc.) */
  metadata?: Record<string, unknown>;
  created_at?: Date;
  updated_at?: Date;
}

/** Runtime classification parameters for phrase types */
export interface ClassificationConfig {
  /** Configuration identifier, 'default' or course-specific override */
  config_key: string;
  /** Number of longest phrases to classify as eternal */
  eternal_count: number;
  /** How to select eternal phrases */
  eternal_selection_mode: 'top_n' | 'min_word_count' | 'percentage';
  /** Maximum debut phrases per LEGO */
  debut_max?: number;
  /** Future tuning parameters for A/B testing and per-course optimization */
  metadata?: Record<string, unknown>;
  created_at?: Date;
  updated_at?: Date;
}

/** Configuration for Voice Activity Detection during PAUSE phase */
export interface VADConfig {
  /** RMS energy level above which we consider 'speaking' */
  energy_threshold_db: number;
  /** Consecutive frames above threshold to confirm speech */
  min_frames_above: number;
  /** FFT window size for frequency analysis */
  fft_size: number;
  /** AnalyserNode smoothing time constant */
  smoothing: number;
}

/** Result of Voice Activity Detection for a single PAUSE phase */
export interface VADResult {
  /** Whether voice activity was detected */
  speech_detected: boolean;
  /** Duration of detected speech in milliseconds */
  speech_duration_ms: number;
  /** Peak energy level during monitoring (dB) */
  peak_energy_db: number;
  /** Average energy level during monitoring (dB) */
  average_energy_db: number;
  /** Percentage of PAUSE duration with detected speech */
  activity_ratio: number;
  /** Timestamp when monitoring started */
  start_time: number;
  /** Timestamp when monitoring ended */
  end_time: number;
}

/** A detected prosody peak (roughly corresponds to a syllable) */
export interface ProsodyPeak {
  /** Time offset from recording start in milliseconds */
  time_ms: number;
  /** Peak amplitude (normalized) */
  amplitude: number;
  /** Rising gradient (rate of amplitude increase before peak) */
  gradient_rise: number;
  /** Falling gradient (rate of amplitude decrease after peak) */
  gradient_fall: number;
  /** Peak prominence relative to surrounding signal */
  prominence: number;
}

/** Complete prosody profile for an audio segment */
export interface ProsodyProfile {
  /** Detected peaks (syllables) */
  peaks: ProsodyPeak[];
  /** Overall rhythm regularity score (1=perfectly regular) */
  rhythm_score: number;
  /** Speech rate (estimated syllables per second) */
  speech_rate: number;
  /** Energy variance across the segment */
  energy_variance: number;
  /** Total duration in milliseconds */
  duration_ms: number;
  /** Average gradient sharpness (crispness indicator) */
  average_gradient_sharpness: number;
}

/** Configuration for prosody analysis */
export interface ProsodyConfig {
  /** Minimum peak prominence to detect */
  min_peak_prominence: number;
  /** Minimum time between peaks in milliseconds */
  min_peak_distance_ms: number;
  /** Window size for gradient calculation in samples */
  gradient_window: number;
  /** Sample rate for analysis (Hz) */
  sample_rate: number;
}

/** Configuration for pause extension after discontinuity detection */
export interface PauseExtensionConfig {
  /** Whether pause extension is active */
  enabled: boolean;
  /** Multiplier: effective_pause = base_pause * (1 + factor) */
  extension_factor: number;
  /** Number of items to maintain extended pause */
  duration_items: number;
}

/** Runtime state for pause extension */
export interface PauseExtensionState {
  /** Whether pause is currently extended */
  isExtended: boolean;
  /** Number of items remaining with extended pause */
  itemsRemaining: number;
  /** The extension factor being applied */
  factor: number;
}

/** Persisted learner tempo profile for global adaptation */
export interface LearnerTempoProfile {
  /** Foreign key to learner */
  learner_id: string;
  /** Current tempo classification */
  tempo_band: TempoBand;
  /** Current consistency classification */
  consistency_band: ConsistencyBand;
  /** Average response time normalized by phrase length */
  mean_normalized_latency: number;
  /** Response time stddev / mean (consistency measure) */
  variance_coefficient: number;
  /** Whether initial assessment phase is complete */
  assessment_complete: boolean;
  /** Number of items observed during assessment */
  assessment_item_count: number;
  /** Sessions since last band change (for stability) */
  sessions_in_current_band: number;
  /** When profile was last updated */
  last_refined_at?: Date;
  /** When profile was created */
  created_at: Date;
}

/** Configuration for tempo profile assessment and adjustments */
export interface TempoProfileConfig {
  /** Items to observe before initial classification */
  assessment_item_count: number;
  /** Minimum valid responses needed */
  assessment_complete_threshold: number;
  /** Upper bound for very_fast classification */
  very_fast_threshold: number;
  fast_threshold: number;
  medium_threshold: number;
  slow_threshold: number;
  /** Items over which to calculate refined tempo */
  refinement_window: number;
  /** EMA weight for profile updates */
  refinement_weight: number;
  /** Maximum tempo band shifts per session */
  max_band_shift_per_session: number;
  /** Sessions of consistent data before band shift */
  stability_threshold: number;
}

/** Calculated parameter adjustments based on tempo profile */
export interface TempoAdjustments {
  /** Multiplier for pause duration (0.7 - 1.4) */
  base_pause_multiplier: number;
  /** Multiplier for transition gaps */
  transition_gap_multiplier: number;
  /** Adjustment to spike detection threshold */
  stddev_threshold_adjustment: number;
  /** Adjustment to pause extension factor */
  extension_factor_adjustment: number;
  /** Adjustment to minimum samples for pattern detection */
  min_samples_adjustment: number;
}
